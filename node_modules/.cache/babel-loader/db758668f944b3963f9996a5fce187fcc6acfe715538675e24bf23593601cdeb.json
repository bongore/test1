{"ast":null,"code":"import { WebSocket } from 'isows';\nimport { HttpRequestError, TimeoutError, WebSocketRequestError } from '../errors/request.js';\nimport { createBatchScheduler } from './promise/createBatchScheduler.js';\nimport { withTimeout } from './promise/withTimeout.js';\nimport { stringify } from './stringify.js';\nlet id = 0;\nasync function http(url, _ref) {\n  let {\n    body,\n    fetchOptions = {},\n    timeout = 10000\n  } = _ref;\n  const {\n    headers,\n    method,\n    signal: signal_\n  } = fetchOptions;\n  try {\n    var _response$headers$get;\n    const response = await withTimeout(async _ref2 => {\n      var _body$id2;\n      let {\n        signal\n      } = _ref2;\n      const response = await fetch(url, {\n        ...fetchOptions,\n        body: Array.isArray(body) ? stringify(body.map(body => {\n          var _body$id;\n          return {\n            jsonrpc: '2.0',\n            id: (_body$id = body.id) !== null && _body$id !== void 0 ? _body$id : id++,\n            ...body\n          };\n        })) : stringify({\n          jsonrpc: '2.0',\n          id: (_body$id2 = body.id) !== null && _body$id2 !== void 0 ? _body$id2 : id++,\n          ...body\n        }),\n        headers: {\n          ...headers,\n          'Content-Type': 'application/json'\n        },\n        method: method || 'POST',\n        signal: signal_ || (timeout > 0 ? signal : undefined)\n      });\n      return response;\n    }, {\n      errorInstance: new TimeoutError({\n        body,\n        url\n      }),\n      timeout,\n      signal: true\n    });\n    let data;\n    if ((_response$headers$get = response.headers.get('Content-Type')) !== null && _response$headers$get !== void 0 && _response$headers$get.startsWith('application/json')) {\n      data = await response.json();\n    } else {\n      data = await response.text();\n    }\n    if (!response.ok) {\n      throw new HttpRequestError({\n        body,\n        details: stringify(data.error) || response.statusText,\n        headers: response.headers,\n        status: response.status,\n        url\n      });\n    }\n    return data;\n  } catch (err) {\n    if (err instanceof HttpRequestError) throw err;\n    if (err instanceof TimeoutError) throw err;\n    throw new HttpRequestError({\n      body,\n      details: err.message,\n      url\n    });\n  }\n}\nexport const socketsCache = /*#__PURE__*/new Map();\nexport async function getSocket(url) {\n  let socket = socketsCache.get(url);\n  // If the socket already exists, return it.\n  if (socket) return socket;\n  const {\n    schedule\n  } = createBatchScheduler({\n    id: url,\n    fn: async () => {\n      const webSocket = new WebSocket(url);\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map();\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map();\n      const onMessage = _ref3 => {\n        let {\n          data\n        } = _ref3;\n        const message = JSON.parse(data);\n        const isSubscription = message.method === 'eth_subscription';\n        const id = isSubscription ? message.params.subscription : message.id;\n        const cache = isSubscription ? subscriptions : requests;\n        const callback = cache.get(id);\n        if (callback) callback({\n          data\n        });\n        if (!isSubscription) cache.delete(id);\n      };\n      const onClose = () => {\n        socketsCache.delete(url);\n        webSocket.removeEventListener('close', onClose);\n        webSocket.removeEventListener('message', onMessage);\n      };\n      // Setup event listeners for RPC & subscription responses.\n      webSocket.addEventListener('close', onClose);\n      webSocket.addEventListener('message', onMessage);\n      // Wait for the socket to open.\n      if (webSocket.readyState === WebSocket.CONNECTING) {\n        await new Promise((resolve, reject) => {\n          if (!webSocket) return;\n          webSocket.onopen = resolve;\n          webSocket.onerror = reject;\n        });\n      }\n      // Create a new socket instance.\n      socket = Object.assign(webSocket, {\n        requests,\n        subscriptions\n      });\n      socketsCache.set(url, socket);\n      return [socket];\n    }\n  });\n  const [_, [socket_]] = await schedule();\n  return socket_;\n}\nfunction webSocket(socket, _ref4) {\n  let {\n    body,\n    onResponse\n  } = _ref4;\n  if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING) throw new WebSocketRequestError({\n    body,\n    url: socket.url,\n    details: 'Socket is closed.'\n  });\n  const id_ = id++;\n  const callback = _ref5 => {\n    let {\n      data\n    } = _ref5;\n    const message = JSON.parse(data);\n    if (typeof message.id === 'number' && id_ !== message.id) return;\n    onResponse === null || onResponse === void 0 || onResponse(message);\n    // If we are subscribing to a topic, we want to set up a listener for incoming\n    // messages.\n    if (body.method === 'eth_subscribe' && typeof message.result === 'string') {\n      socket.subscriptions.set(message.result, callback);\n    }\n    // If we are unsubscribing from a topic, we want to remove the listener.\n    if (body.method === 'eth_unsubscribe') {\n      var _body$params;\n      socket.subscriptions.delete((_body$params = body.params) === null || _body$params === void 0 ? void 0 : _body$params[0]);\n    }\n  };\n  socket.requests.set(id_, callback);\n  socket.send(JSON.stringify({\n    jsonrpc: '2.0',\n    ...body,\n    id: id_\n  }));\n  return socket;\n}\nasync function webSocketAsync(socket, _ref6) {\n  let {\n    body,\n    timeout = 10000\n  } = _ref6;\n  return withTimeout(() => new Promise(onResponse => rpc.webSocket(socket, {\n    body,\n    onResponse\n  })), {\n    errorInstance: new TimeoutError({\n      body,\n      url: socket.url\n    }),\n    timeout\n  });\n}\n///////////////////////////////////////////////////\nexport const rpc = {\n  http,\n  webSocket,\n  webSocketAsync\n};","map":{"version":3,"names":["WebSocket","HttpRequestError","TimeoutError","WebSocketRequestError","createBatchScheduler","withTimeout","stringify","id","http","url","_ref","body","fetchOptions","timeout","headers","method","signal","signal_","_response$headers$get","response","_ref2","_body$id2","fetch","Array","isArray","map","_body$id","jsonrpc","undefined","errorInstance","data","get","startsWith","json","text","ok","details","error","statusText","status","err","message","socketsCache","Map","getSocket","socket","schedule","fn","webSocket","requests","subscriptions","onMessage","_ref3","JSON","parse","isSubscription","params","subscription","cache","callback","delete","onClose","removeEventListener","addEventListener","readyState","CONNECTING","Promise","resolve","reject","onopen","onerror","Object","assign","set","_","socket_","_ref4","onResponse","CLOSED","CLOSING","id_","_ref5","result","_body$params","send","webSocketAsync","_ref6","rpc"],"sources":["C:\\Users\\takap\\OneDrive - Chiba Institute of Technology\\デスクトップ\\web3-sotuken\\node_modules\\viem\\utils\\rpc.ts"],"sourcesContent":["import { WebSocket } from 'isows'\nimport type { MessageEvent } from 'isows'\n\nimport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n  TimeoutError,\n  type TimeoutErrorType,\n  WebSocketRequestError,\n} from '../errors/request.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport {\n  type CreateBatchSchedulerErrorType,\n  createBatchScheduler,\n} from './promise/createBatchScheduler.js'\nimport {\n  type WithTimeoutErrorType,\n  withTimeout,\n} from './promise/withTimeout.js'\nimport { stringify } from './stringify.js'\n\nlet id = 0\n\ntype SuccessResult<T> = {\n  method?: never\n  result: T\n  error?: never\n}\ntype ErrorResult<T> = {\n  method?: never\n  result?: never\n  error: T\n}\ntype Subscription<TResult, TError> = {\n  method: 'eth_subscription'\n  error?: never\n  result?: never\n  params: {\n    subscription: string\n  } & (\n    | {\n        result: TResult\n        error?: never\n      }\n    | {\n        result?: never\n        error: TError\n      }\n  )\n}\n\nexport type RpcRequest = { method: string; params?: any; id?: number }\n\nexport type RpcResponse<TResult = any, TError = any> = {\n  jsonrpc: `${number}`\n  id: number\n} & (\n  | SuccessResult<TResult>\n  | ErrorResult<TError>\n  | Subscription<TResult, TError>\n)\n\n///////////////////////////////////////////////////\n// HTTP\n\nexport type HttpOptions<TBody extends RpcRequest | RpcRequest[] = RpcRequest> =\n  {\n    // The RPC request body.\n    body: TBody\n    // Request configuration to pass to `fetch`.\n    fetchOptions?: Omit<RequestInit, 'body'>\n    // The timeout (in ms) for the request.\n    timeout?: number\n  }\n\nexport type HttpReturnType<\n  TBody extends RpcRequest | RpcRequest[] = RpcRequest,\n> = TBody extends RpcRequest[] ? RpcResponse[] : RpcResponse\n\nexport type HttpErrorType =\n  | HttpRequestErrorType\n  | TimeoutErrorType\n  | WithTimeoutErrorType\n  | ErrorType\n\nasync function http<TBody extends RpcRequest | RpcRequest[]>(\n  url: string,\n  { body, fetchOptions = {}, timeout = 10_000 }: HttpOptions<TBody>,\n): Promise<HttpReturnType<TBody>> {\n  const { headers, method, signal: signal_ } = fetchOptions\n  try {\n    const response = await withTimeout(\n      async ({ signal }) => {\n        const response = await fetch(url, {\n          ...fetchOptions,\n          body: Array.isArray(body)\n            ? stringify(\n                body.map((body) => ({\n                  jsonrpc: '2.0',\n                  id: body.id ?? id++,\n                  ...body,\n                })),\n              )\n            : stringify({ jsonrpc: '2.0', id: body.id ?? id++, ...body }),\n          headers: {\n            ...headers,\n            'Content-Type': 'application/json',\n          },\n          method: method || 'POST',\n          signal: signal_ || (timeout > 0 ? signal : undefined),\n        })\n        return response\n      },\n      {\n        errorInstance: new TimeoutError({ body, url }),\n        timeout,\n        signal: true,\n      },\n    )\n\n    let data\n    if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n      data = await response.json()\n    } else {\n      data = await response.text()\n    }\n\n    if (!response.ok) {\n      throw new HttpRequestError({\n        body,\n        details: stringify(data.error) || response.statusText,\n        headers: response.headers,\n        status: response.status,\n        url,\n      })\n    }\n\n    return data\n  } catch (err) {\n    if (err instanceof HttpRequestError) throw err\n    if (err instanceof TimeoutError) throw err\n    throw new HttpRequestError({\n      body,\n      details: (err as Error).message,\n      url,\n    })\n  }\n}\n\n///////////////////////////////////////////////////\n// WebSocket\n\ntype Id = string | number\ntype CallbackFn = (message: any) => void\ntype CallbackMap = Map<Id, CallbackFn>\n\nexport type Socket = WebSocket & {\n  requests: CallbackMap\n  subscriptions: CallbackMap\n}\n\nexport type GetSocketErrorType = CreateBatchSchedulerErrorType | ErrorType\n\nexport const socketsCache = /*#__PURE__*/ new Map<string, Socket>()\n\nexport async function getSocket(url: string) {\n  let socket = socketsCache.get(url)\n\n  // If the socket already exists, return it.\n  if (socket) return socket\n\n  const { schedule } = createBatchScheduler<undefined, [Socket]>({\n    id: url,\n    fn: async () => {\n      const webSocket = new WebSocket(url)\n\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map<Id, CallbackFn>()\n\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map<Id, CallbackFn>()\n\n      const onMessage: (event: MessageEvent) => void = ({ data }) => {\n        const message: RpcResponse = JSON.parse(data as string)\n        const isSubscription = message.method === 'eth_subscription'\n        const id = isSubscription ? message.params.subscription : message.id\n        const cache = isSubscription ? subscriptions : requests\n        const callback = cache.get(id)\n        if (callback) callback({ data })\n        if (!isSubscription) cache.delete(id)\n      }\n      const onClose = () => {\n        socketsCache.delete(url)\n        webSocket.removeEventListener('close', onClose)\n        webSocket.removeEventListener('message', onMessage)\n      }\n\n      // Setup event listeners for RPC & subscription responses.\n      webSocket.addEventListener('close', onClose)\n      webSocket.addEventListener('message', onMessage)\n\n      // Wait for the socket to open.\n      if (webSocket.readyState === WebSocket.CONNECTING) {\n        await new Promise((resolve, reject) => {\n          if (!webSocket) return\n          webSocket.onopen = resolve\n          webSocket.onerror = reject\n        })\n      }\n\n      // Create a new socket instance.\n      socket = Object.assign(webSocket, {\n        requests,\n        subscriptions,\n      })\n      socketsCache.set(url, socket)\n\n      return [socket]\n    },\n  })\n\n  const [_, [socket_]] = await schedule()\n  return socket_\n}\n\nexport type WebSocketOptions = {\n  /** The RPC request body. */\n  body: RpcRequest\n  /** The callback to invoke on response. */\n  onResponse?: (message: RpcResponse) => void\n}\n\nexport type WebSocketReturnType = Socket\n\nexport type WebSocketErrorType = WebSocketRequestError | ErrorType\n\nfunction webSocket(\n  socket: Socket,\n  { body, onResponse }: WebSocketOptions,\n): WebSocketReturnType {\n  if (\n    socket.readyState === socket.CLOSED ||\n    socket.readyState === socket.CLOSING\n  )\n    throw new WebSocketRequestError({\n      body,\n      url: socket.url,\n      details: 'Socket is closed.',\n    })\n\n  const id_ = id++\n\n  const callback = ({ data }: { data: any }) => {\n    const message: RpcResponse = JSON.parse(data)\n\n    if (typeof message.id === 'number' && id_ !== message.id) return\n\n    onResponse?.(message)\n\n    // If we are subscribing to a topic, we want to set up a listener for incoming\n    // messages.\n    if (body.method === 'eth_subscribe' && typeof message.result === 'string') {\n      socket.subscriptions.set(message.result, callback)\n    }\n\n    // If we are unsubscribing from a topic, we want to remove the listener.\n    if (body.method === 'eth_unsubscribe') {\n      socket.subscriptions.delete(body.params?.[0])\n    }\n  }\n  socket.requests.set(id_, callback)\n\n  socket.send(JSON.stringify({ jsonrpc: '2.0', ...body, id: id_ }))\n\n  return socket\n}\n\nexport type WebSocketAsyncOptions = {\n  /** The RPC request body. */\n  body: RpcRequest\n  /** The timeout (in ms) for the request. */\n  timeout?: number\n}\n\nexport type WebSocketAsyncReturnType = RpcResponse\n\nexport type WebSocketAsyncErrorType =\n  | WebSocketErrorType\n  | TimeoutErrorType\n  | WithTimeoutErrorType\n  | ErrorType\n\nasync function webSocketAsync(\n  socket: Socket,\n  { body, timeout = 10_000 }: WebSocketAsyncOptions,\n): Promise<WebSocketAsyncReturnType> {\n  return withTimeout(\n    () =>\n      new Promise<RpcResponse>((onResponse) =>\n        rpc.webSocket(socket, {\n          body,\n          onResponse,\n        }),\n      ),\n    {\n      errorInstance: new TimeoutError({ body, url: socket.url }),\n      timeout,\n    },\n  )\n}\n\n///////////////////////////////////////////////////\n\nexport const rpc = {\n  http,\n  webSocket,\n  webSocketAsync,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}