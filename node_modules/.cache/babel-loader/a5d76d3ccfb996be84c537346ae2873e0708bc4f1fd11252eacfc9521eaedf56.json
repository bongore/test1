{"ast":null,"code":"export function withTimeout(fn, _ref) {\n  let {\n    errorInstance = new Error('timed out'),\n    timeout,\n    signal\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    ;\n    (async () => {\n      let timeoutId;\n      try {\n        const controller = new AbortController();\n        if (timeout > 0) {\n          timeoutId = setTimeout(() => {\n            if (signal) {\n              controller.abort();\n            } else {\n              reject(errorInstance);\n            }\n          }, timeout);\n        }\n        resolve(await fn({\n          signal: controller === null || controller === void 0 ? void 0 : controller.signal\n        }));\n      } catch (err) {\n        if (err.name === 'AbortError') reject(errorInstance);\n        reject(err);\n      } finally {\n        clearTimeout(timeoutId);\n      }\n    })();\n  });\n}","map":{"version":3,"names":["withTimeout","fn","_ref","errorInstance","Error","timeout","signal","Promise","resolve","reject","timeoutId","controller","AbortController","setTimeout","abort","err","name","clearTimeout"],"sources":["C:\\Users\\takap\\OneDrive - Chiba Institute of Technology\\デスクトップ\\web3-sotuken\\node_modules\\viem\\utils\\promise\\withTimeout.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\n\nexport type WithTimeoutErrorType = ErrorType\n\nexport function withTimeout<TData>(\n  fn: ({ signal }: { signal?: AbortController['signal'] }) => Promise<TData>,\n  {\n    errorInstance = new Error('timed out'),\n    timeout,\n    signal,\n  }: {\n    // The error instance to throw when the timeout is reached.\n    errorInstance?: Error\n    // The timeout (in ms).\n    timeout: number\n    // Whether or not the timeout should use an abort signal.\n    signal?: boolean\n  },\n): Promise<TData> {\n  return new Promise((resolve, reject) => {\n    ;(async () => {\n      let timeoutId!: NodeJS.Timeout\n      try {\n        const controller = new AbortController()\n        if (timeout > 0) {\n          timeoutId = setTimeout(() => {\n            if (signal) {\n              controller.abort()\n            } else {\n              reject(errorInstance)\n            }\n          }, timeout)\n        }\n        resolve(await fn({ signal: controller?.signal }))\n      } catch (err) {\n        if ((err as Error).name === 'AbortError') reject(errorInstance)\n        reject(err)\n      } finally {\n        clearTimeout(timeoutId)\n      }\n    })()\n  })\n}\n"],"mappings":"AAIA,OAAM,SAAUA,WAAWA,CACzBC,EAA0E,EAAAC,IAAA,EAYzE;EAAA,IAXD;IACEC,aAAa,GAAG,IAAIC,KAAK,CAAC,WAAW,CAAC;IACtCC,OAAO;IACPC;EAAM,CAQP,GAAAJ,IAAA;EAED,OAAO,IAAIK,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;IACrC;IAAC,CAAC,YAAW;MACX,IAAIC,SAA0B;MAC9B,IAAI;QACF,MAAMC,UAAU,GAAG,IAAIC,eAAe,EAAE;QACxC,IAAIP,OAAO,GAAG,CAAC,EAAE;UACfK,SAAS,GAAGG,UAAU,CAAC,MAAK;YAC1B,IAAIP,MAAM,EAAE;cACVK,UAAU,CAACG,KAAK,EAAE;aACnB,MAAM;cACLL,MAAM,CAACN,aAAa,CAAC;;UAEzB,CAAC,EAAEE,OAAO,CAAC;;QAEbG,OAAO,CAAC,MAAMP,EAAE,CAAC;UAAEK,MAAM,EAAEK,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEL;QAAM,CAAE,CAAC,CAAC;OAClD,CAAC,OAAOS,GAAG,EAAE;QACZ,IAAKA,GAAa,CAACC,IAAI,KAAK,YAAY,EAAEP,MAAM,CAACN,aAAa,CAAC;QAC/DM,MAAM,CAACM,GAAG,CAAC;OACZ,SAAS;QACRE,YAAY,CAACP,SAAS,CAAC;;IAE3B,CAAC,EAAC,CAAE;EACN,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}