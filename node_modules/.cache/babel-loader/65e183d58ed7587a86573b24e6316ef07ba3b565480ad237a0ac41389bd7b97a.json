{"ast":null,"code":"import { BaseError } from '../../errors/base.js';\nimport { InvalidHexValueError } from '../../errors/encoding.js';\nimport { createCursor } from '../cursor.js';\nimport { hexToBytes } from './toBytes.js';\nimport { bytesToHex } from './toHex.js';\nexport function fromRlp(value) {\n  let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n  const bytes = (() => {\n    if (typeof value === 'string') {\n      if (value.length > 3 && value.length % 2 !== 0) throw new InvalidHexValueError(value);\n      return hexToBytes(value);\n    }\n    return value;\n  })();\n  const cursor = createCursor(bytes);\n  const result = fromRlpCursor(cursor, to);\n  return result;\n}\nexport function rlpToBytes(bytes) {\n  let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bytes';\n  return fromRlp(bytes, to);\n}\nexport function rlpToHex(hex) {\n  let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n  return fromRlp(hex, to);\n}\nfunction fromRlpCursor(cursor) {\n  let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n  if (cursor.bytes.length === 0) return to === 'hex' ? bytesToHex(cursor.bytes) : cursor.bytes;\n  const prefix = cursor.readByte();\n  if (prefix < 0x80) cursor.decrementPosition(1);\n  // bytes\n  if (prefix < 0xc0) {\n    const length = readLength(cursor, prefix, 0x80);\n    const bytes = cursor.readBytes(length);\n    return to === 'hex' ? bytesToHex(bytes) : bytes;\n  }\n  // list\n  const length = readLength(cursor, prefix, 0xc0);\n  return readList(cursor, length, to);\n}\nfunction readLength(cursor, prefix, offset) {\n  if (offset === 0x80 && prefix < 0x80) return 1;\n  if (prefix <= offset + 55) return prefix - offset;\n  if (prefix === offset + 55 + 1) return cursor.readUint8();\n  if (prefix === offset + 55 + 2) return cursor.readUint16();\n  if (prefix === offset + 55 + 3) return cursor.readUint24();\n  if (prefix === offset + 55 + 4) return cursor.readUint32();\n  throw new BaseError('Invalid RLP prefix');\n}\nfunction readList(cursor, length, to) {\n  const position = cursor.position;\n  const value = [];\n  while (cursor.position - position < length) value.push(fromRlpCursor(cursor, to));\n  return value;\n}","map":{"version":3,"names":["BaseError","InvalidHexValueError","createCursor","hexToBytes","bytesToHex","fromRlp","value","to","arguments","length","undefined","bytes","cursor","result","fromRlpCursor","rlpToBytes","rlpToHex","hex","prefix","readByte","decrementPosition","readLength","readBytes","readList","offset","readUint8","readUint16","readUint24","readUint32","position","push"],"sources":["C:\\Users\\takap\\OneDrive - Chiba Institute of Technology\\デスクトップ\\web3-sotuken\\node_modules\\viem\\utils\\encoding\\fromRlp.ts"],"sourcesContent":["import { BaseError, type BaseErrorType } from '../../errors/base.js'\nimport {\n  InvalidHexValueError,\n  type InvalidHexValueErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nimport type { RecursiveArray } from './toRlp.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type FromRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? RecursiveArray<ByteArray> : never)\n  | (to extends 'hex' ? RecursiveArray<Hex> : never)\n\nexport type FromRlpErrorType =\n  | CreateCursorErrorType\n  | FromRlpCursorErrorType\n  | HexToBytesErrorType\n  | InvalidHexValueErrorType\n  | ErrorType\n\nexport function fromRlp<to extends To = 'hex'>(\n  value: ByteArray | Hex,\n  to: to | To | undefined = 'hex',\n): FromRlpReturnType<to> {\n  const bytes = (() => {\n    if (typeof value === 'string') {\n      if (value.length > 3 && value.length % 2 !== 0)\n        throw new InvalidHexValueError(value)\n      return hexToBytes(value)\n    }\n    return value\n  })()\n\n  const cursor = createCursor(bytes)\n  const result = fromRlpCursor(cursor, to)\n\n  return result as FromRlpReturnType<to>\n}\n\nexport type RlpToBytesErrorType = FromRlpErrorType | ErrorType\n\nexport function rlpToBytes<to extends To = 'bytes'>(\n  bytes: ByteArray,\n  to: to | To | undefined = 'bytes',\n): FromRlpReturnType<to> {\n  return fromRlp(bytes, to)\n}\n\nexport type RlpToHexErrorType = FromRlpErrorType | ErrorType\n\nexport function rlpToHex<to extends To = 'hex'>(\n  hex: Hex,\n  to: to | To | undefined = 'hex',\n): FromRlpReturnType<to> {\n  return fromRlp(hex, to)\n}\n\nexport type FromRlpCursorErrorType =\n  | BytesToHexErrorType\n  | ReadLengthErrorType\n  | ReadListErrorType\n  | ErrorType\n\nfunction fromRlpCursor<to extends To = 'hex'>(\n  cursor: Cursor,\n  to: to | To | undefined = 'hex',\n): FromRlpReturnType<to> {\n  if (cursor.bytes.length === 0)\n    return (\n      to === 'hex' ? bytesToHex(cursor.bytes) : cursor.bytes\n    ) as FromRlpReturnType<to>\n\n  const prefix = cursor.readByte()\n  if (prefix < 0x80) cursor.decrementPosition(1)\n\n  // bytes\n  if (prefix < 0xc0) {\n    const length = readLength(cursor, prefix, 0x80)\n    const bytes = cursor.readBytes(length)\n    return (to === 'hex' ? bytesToHex(bytes) : bytes) as FromRlpReturnType<to>\n  }\n\n  // list\n  const length = readLength(cursor, prefix, 0xc0)\n  return readList(cursor, length, to) as {} as FromRlpReturnType<to>\n}\n\nexport type ReadLengthErrorType = BaseErrorType | ErrorType\n\nfunction readLength(cursor: Cursor, prefix: number, offset: number) {\n  if (offset === 0x80 && prefix < 0x80) return 1\n  if (prefix <= offset + 55) return prefix - offset\n  if (prefix === offset + 55 + 1) return cursor.readUint8()\n  if (prefix === offset + 55 + 2) return cursor.readUint16()\n  if (prefix === offset + 55 + 3) return cursor.readUint24()\n  if (prefix === offset + 55 + 4) return cursor.readUint32()\n  throw new BaseError('Invalid RLP prefix')\n}\n\nexport type ReadListErrorType = ErrorType\n\nfunction readList<to extends To>(cursor: Cursor, length: number, to: to | To) {\n  const position = cursor.position\n  const value: FromRlpReturnType<to>[] = []\n  while (cursor.position - position < length)\n    value.push(fromRlpCursor(cursor, to))\n  return value\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}